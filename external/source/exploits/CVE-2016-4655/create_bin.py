#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Create binary from Mach-O file for CVE-2016-4655

NOTE: This script requires the macholib Python library:
pip install macholib

The Ruby version uses the 'macho' gem. This Python version uses macholib
which provides similar functionality for parsing Mach-O files.
"""

import sys
from macholib.MachO import MachO


def main():
    if len(sys.argv) < 2:
        print("Usage: create_bin.py <stager_file>", file=sys.stderr)
        sys.exit(1)
    
    stager_file = sys.argv[1]
    
    try:
        with open(stager_file, 'rb') as f:
            data = f.read()
    except IOError as e:
        print(f"Error reading file: {e}", file=sys.stderr)
        sys.exit(1)
    
    try:
        macho = MachO(stager_file)
    except Exception as e:
        print(f"Error parsing Mach-O file: {e}", file=sys.stderr)
        sys.exit(1)
    
    start = -1
    min_addr = -1
    max_addr = 0
    
    for header in macho.headers:
        for cmd in header.commands:
            # Skip __PAGEZERO segment
            if hasattr(cmd[1], 'segname') and cmd[1].segname.decode('utf-8').rstrip('\x00') == '__PAGEZERO':
                continue
            
            if hasattr(cmd[1], 'vmaddr') and hasattr(cmd[1], 'vmsize'):
                segment = cmd[1]
                segname = segment.segname.decode('utf-8').rstrip('\x00')
                print(f"segment: {segname} {segment.vmaddr:x}")
                
                if min_addr == -1 or min_addr > segment.vmaddr:
                    min_addr = segment.vmaddr
                
                if max_addr < segment.vmaddr + segment.vmsize:
                    max_addr = segment.vmaddr + segment.vmsize
    
    print(f"data: {min_addr:x} -> {max_addr:x} {max_addr - min_addr:x}")
    output_data = bytearray(b'\x00' * (max_addr - min_addr))
    
    for header in macho.headers:
        for cmd in header.commands:
            if hasattr(cmd[1], 'segname'):
                segment = cmd[1]
                segname = segment.segname.decode('utf-8').rstrip('\x00')
                
                print(f"segment: {segname} off: {segment.offset:x} vmaddr: {segment.vmaddr:x} fileoff: {segment.fileoff:x}")
                
                # Process sections if they exist
                if hasattr(cmd[1], 'sections'):
                    for section in cmd[1].sections:
                        sectname = section.sectname.decode('utf-8').rstrip('\x00')
                        print(f"section: {sectname} off: {section.offset:x} addr: {section.addr:x} size: {section.size:x}")
                        
                        flat_addr = section.addr - min_addr
                        section_data = data[section.offset:section.offset + section.size]
                        
                        if section_data:
                            print(f"flat_addr: {flat_addr:x} ({len(section_data):x})")
                            if start == -1 or start > flat_addr:
                                start = flat_addr
                            output_data[flat_addr:flat_addr + len(section_data)] = section_data
    
    print(f"start: {start:x}")
    output_data = output_data[start:]
    
    with open(stager_file + ".bin", 'wb') as f:
        f.write(output_data)
    
    print(f"Binary written to {stager_file}.bin")


if __name__ == "__main__":
    main()
